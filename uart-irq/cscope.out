cscope 15 $HOME/code/fastmodels-code/uart-irq -q 0000000126 0000006613
	@start.c

1 
	tušt
;

2 
	tushÜt
;

3 
	tuch¬
;

4 
	tušt32
;

5 
	tušt16
;

6 
	tušt8
;

8 #iâdeà
NULL


9 
	#NULL
 ((*)0)

	)

12 
	#UART0
 0x1c090000

	)

13 
	#UART_CLK
 24000000

14 

	)

15 
	#UART_DR
 0

16 
	#UART_RSR
 1

17 
	#UART_FR
 6

18 
	#UART_IBRD
 9

19 
	#UART_FBRD
 10

20 
	#UART_LCR
 11

21 
	#UART_CR
 12

22 
	#UART_IMSC
 14

23 
	#UART_MIS
 16

24 
	#UART_ICR
 17

26 
	#UARTFR_TXFF
 (1 << 5)

27 
	#UARTFR_RXFE
 (1 << 4)

28 
	#UARTCR_RXE
 (1 << 9)

29 
	#UARTCR_TXE
 (1 << 8)

30 
	#UARTCR_EN
 (1 << 0)

31 
	#UARTLCR_FEN
 (1 << 4)

32 
	#UART_RXI
 (1 << 4)

33 
	#UART_TXI
 (1 << 5)

34 
	#UART_BITRATE
 19200

	)

36 
	#VIC_BASE
 0x2c000000

	)

37 
	#PIC_TIMER01
 2

	)

38 
	#PIC_TIMER23
 3

	)

39 
	#PIC_UART0
 5

	)

40 
	#PIC_GRAPHIC
 19

	)

42 
	#SGI_TYPE
 1

	)

43 
	#PPI_TYPE
 2

	)

44 
	#SPI_TYPE
 3

	)

46 
	#GICD_CTLR
 0x000

	)

47 
	#GICD_TYPER
 0x004

	)

48 
	#GICD_IIDR
 0x008

	)

50 
	#GICD_IGROUP
 0x080

	)

51 
	#GICD_ISENABLE
 0x100

	)

52 
	#GICD_ICENABLE
 0x180

	)

53 
	#GICD_ISPEND
 0x200

	)

54 
	#GICD_ICPEND
 0x280

	)

55 
	#GICD_ISACTIVE
 0x300

	)

56 
	#GICD_ICACTIVE
 0x380

	)

57 
	#GICD_IPRIORITY
 0x400

	)

58 
	#GICD_ITARGET
 0x800

	)

59 
	#GICD_ICFG
 0xC00

	)

61 
	#GICC_CTLR
 0x000

	)

62 
	#GICC_PMR
 0x004

	)

63 
	#GICC_BPR
 0x008

	)

64 
	#GICC_IAR
 0x00C

	)

65 
	#GICC_EOIR
 0x010

	)

66 
	#GICC_RRR
 0x014

	)

67 
	#GICC_HPPIR
 0x018

	)

69 
	#GICC_ABPR
 0x01C

	)

70 
	#GICC_AIAR
 0x020

	)

71 
	#GICC_AEOIR
 0x024

	)

72 
	#GICC_AHPPIR
 0x028

	)

74 
	#GICC_APR
 0x0D0

	)

75 
	#GICC_NSAPR
 0x0E0

	)

76 
	#GICC_IIDR
 0x0FC

	)

77 
	#GICC_DIR
 0x1000

	)

79 vÞ©ž
ušt
* 
	ggic_ba£
;

81 
	#GICD_REG
(
o
è(*(
ušt
 *)(((uštè
gic_ba£
è+ 0x1000 + o))

	)

82 
	#GICC_REG
(
o
è(*(
ušt
 *)(((uštè
gic_ba£
è+ 0x2000 + o))

	)

85 
	#NO_INT
 0xc0

	)

86 
	#DIS_INT
 0x80

	)

88 vÞ©ž* cÚ¡ 
	gUART0_BASE
 = (*)0x1c090000;

89 vÞ©ž
ušt
 *
	gu¬t_ba£
;

91 
þi
 ();

92 
¡i
 ();

94 
	$u¬t_£nd
(
c
)

96 *
UART0_BASE
 = 
c
;

97 if(
c
 == '\n')

98 *
UART0_BASE
 = '\r';

99 
	}
}

101 
	$´št¡r
(*
s
)

103 
i
 = 0;

104 
s
[
i
])

106 
	`u¬t_£nd
(
s
[
i
]);

107 
i
++;

109 
	}
}

111 
	$´štšt
(
xx
, 
ba£
, 
sign
)

113 
dig™s
[] = "0123456789abcdef";

114 
buf
[16];

115 
i
;

116 
x
;

118 if(
sign
 && (sigÀð
xx
 < 0))

119 
x
 = -
xx
;

121 
x
 = 
xx
;

123 
i
 = 0;

125 
buf
[
i
++] = 
dig™s
[
x
 % 
ba£
];

126 }(
x
 /ð
ba£
) != 0);

128 if(
sign
)

129 
buf
[
i
++] = '-';

131 --
i
 >= 0)

132 
	`u¬t_£nd
(
buf
[
i
]);

133 
	}
}

135 
	$ýrštf
(*
fmt
, ...)

137 
i
, 
c
;

138 *
¬gp
;

139 *
s
;

141 
¬gp
 = (*)(*)(&
fmt
 + 1);

142 
i
 = 0; (
c
 = 
fmt
[i] & 0xff) != 0; i++)

144 if(
c
 != '%')

146 
	`u¬t_£nd
(
c
);

149 
c
 = 
fmt
[++
i
] & 0xff;

150 if(
c
 == 0)

152 
c
)

155 
	`´štšt
(*
¬gp
++, 10, 1);

159 
	`´štšt
(*
¬gp
++, 16, 0);

162 if((
s
 = (*)*
¬gp
++) == 0)

163 
s
 = "(null)";

164 ; *
s
; s++)

165 
	`u¬t_£nd
(*
s
);

168 
	`u¬t_£nd
('%');

172 
	`u¬t_£nd
('%');

173 
	`u¬t_£nd
(
c
);

177 
	}
}

179 
	$swi_hªdËr
()

181 
	`ýrštf
("In Secure World's SWI Handler\n");

182 
	}
}

184 
	$gic_g‘ack
()

186  
	`GICC_REG
(
GICC_IAR
);

187 
	}
}

189 
	$¥i2id
(
¥i
)

191  
¥i
+32;

192 
	}
}

194 
	$gic_eoi
(
šŠ
)

196 
	`GICC_REG
(
GICC_EOIR
èð
	`¥i2id
(
šŠ
);

197 
	}
}

200 
	$u¬tg‘c
 ()

202 ià(
u¬t_ba£
[
UART_FR
] & 
UARTFR_RXFE
) {

206  
u¬t_ba£
[
UART_DR
];

207 
	}
}

209 
	$hªdË_u¬t_œq
()

213 
c
 = 
	`u¬tg‘c
();

214 
	`ýrštf
("u¬ˆšput: %x\n", 
c
);

218 
u¬t_ba£
[
UART_ICR
] = 
UART_RXI
 | 
UART_TXI
;

219 
	}
}

221 
	$œq_hªdËr
()

223 
štid
, 
šŠ
;

224 
štid
 = 
	`gic_g‘ack
();

225 
šŠ
 = 
štid
 - 32;

226 
	`hªdË_u¬t_œq
();

227 
	`ýrštf
("IRQ Numb” : %d\n", 
šŠ
);

228 
	`gic_eoi
(
šŠ
);

229 
	`¡i
();

230 
	}
}

232 
	$gicd_£t_b™
(
ba£
, 
id
, 
bv®
)

234 
off£t
 = 
id
/32;

235 
b™pos
 = 
id
%32;

236 
ušt
 
rv®
 = 
	`GICD_REG
(
ba£
+4*
off£t
);

237 if(
bv®
)

238 
rv®
 |ð1 << 
b™pos
;

240 
rv®
 &ð~(1<< 
b™pos
);

241 
	`GICD_REG
(
ba£
+ 4*
off£t
èð
rv®
;

242 
	}
}

244 
	$gd_¥i_£tcfg
(
¥i
, 
is_edge
)

246 
id
=
	`¥i2id
(
¥i
);

247 
off£t
 = 
id
/16;

248 
b™pos
 = (
id
%16)*2;

249 
ušt
 
rv®
 = 
	`GICD_REG
(
GICD_ICFG
+4*
off£t
);

250 
ušt
 
vmask
=0x03;

251 
rv®
 &ð~(
vmask
 << 
b™pos
);

252 ià(
is_edge
)

253 
rv®
 |ð0x02 << 
b™pos
;

254 
	`GICD_REG
(
GICD_ICFG
+ 4*
off£t
èð
rv®
;

255 
	}
}

257 
	$gd_¥i_’abË
(
¥i
)

259 
id
 = 
	`¥i2id
(
¥i
);

260 
	`gicd_£t_b™
(
GICD_ISENABLE
, 
id
, 1);

261 
	}
}

263 
	$gd_¥i_group0
(
¥i
)

266 
	}
}

268 
	$gd_¥i_rg‘0
(
¥i
)

270 
id
=
	`¥i2id
(
¥i
);

271 
off£t
 = 
id
/4;

272 
b™pos
 = (
id
%4)*8;

273 
ušt
 
rv®
 = 
	`GICD_REG
(
GICD_ITARGET
+4*
off£t
);

274 
týu
=0x01;

275 
rv®
 |ð
týu
 << 
b™pos
;

276 
	`GICD_REG
(
GICD_ITARGET
+ 4*
off£t
èð
rv®
;

277 
	}
}

279 
	$gic_di¡_cÚfigu»
(
™y³
, 
num
)

281 
¥i
ð
num
;

282 
	`gd_¥i_£tcfg
(
¥i
, 1);

283 
	`gd_¥i_’abË
(
¥i
);

284 
	`gd_¥i_group0
(
¥i
);

285 
	`gd_¥i_rg‘0
(
¥i
);

286 
	}
}

288 
	$gic_cÚfigu»
(
™y³
, 
num
)

290 
	`gic_di¡_cÚfigu»
(
™y³
, 
num
);

291 
	}
}

293 
	$gic_’abË
()

295 
	`GICD_REG
(
GICD_CTLR
) |= 1;

296 
	`GICC_REG
(
GICC_CTLR
) |= 1;

297 
	}
}

299 
	$g™_š™
(
ušt
* 
ba£
)

301 
gic_ba£
 = 
ba£
;

302 
	`GICC_REG
(
GICC_PMR
) = 0x0f;

304 
	`gic_cÚfigu»
(
SPI_TYPE
, 
PIC_UART0
);

305 
	`gic_’abË
();

306 
	}
}

308 
	$þi
 ()

310 
ušt
 
v®
;

312 
asm
 vÞ©že("MRS %[v], cp¤": [
v
]"ô" (
v®
)::);

313 
v®
 |ð
DIS_INT
;

314 
asm
 vÞ©že("MSR cp¤_cxsf, %[v]": :[
v
]"r" (
v®
):);

315 
	}
}

317 
	$¡i
 ()

319 
ušt
 
v®
;

322 
asm
 vÞ©že("MRS %[v], cp¤": [
v
]"ô" (
v®
)::);

323 
v®
 &ð~
DIS_INT
;

324 
asm
 vÞ©že("MSR cp¤_cxsf, %[v]": :[
v
]"r" (
v®
):);

325 
	}
}

328 
	$u¬t_’abË_rx
 ()

330 
u¬t_ba£
[
UART_IMSC
] = 
UART_RXI
;

332 
	}
}

335 
	$u¬t_š™
 (*
addr
)

337 
ušt
 
Ëá
;

339 
u¬t_ba£
 = 
addr
;

342 
u¬t_ba£
[
UART_IBRD
] = 
UART_CLK
 / (16 * 
UART_BITRATE
);

344 
Ëá
 = 
UART_CLK
 % (16 * 
UART_BITRATE
);

345 
u¬t_ba£
[
UART_FBRD
] = (
Ëá
 * 4 + 
UART_BITRATE
 / 2) / UART_BITRATE;

348 
u¬t_ba£
[
UART_CR
] |ð(
UARTCR_EN
 | 
UARTCR_RXE
 | 
UARTCR_TXE
);

351 
u¬t_ba£
[
UART_LCR
] |ð
UARTLCR_FEN
;

352 
	}
}

354 
	$c_¡¬t
()

356 
	`u¬t_š™
((*)
UART0
);

357 
	`g™_š™
((
ušt
 *)
VIC_BASE
);

358 
	`u¬t_’abË_rx
();

359 
	`¡i
();

360 
	`ýrštf
("Startheest!\n");

363 
	}
}

	@
1
.
1
/usr/include
1
8
start.c
